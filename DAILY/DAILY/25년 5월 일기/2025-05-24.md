---
cssclasses:
  - hide-properties_editing
  - hide-properties_reading
---
# Daily Note
```calendar-nav
```
````tabs
tab: Due Today
```tasks
not done
due template_contact
sort by priority
hide due date
limit 10
```
tab: Overdue
```tasks 
not done 
due before template_contact
sort by priority
hide due date
limit 10
```
tab: Completed
```tasks
done template_contact
hide done date
hide due date
limit 10
```
````
# New Tasks


# Daily Notes

## 일기
화염감시창 CCTV가 고장났다.
어제의 정전작업으로 고장나서 이걸 해결하려고 POE와 컨버터를 교체해보았다.
교체 후 제어실에 와서 NVR을 확인했더니 불이 깜박이는 걸 확인했다. 팀장님꼐 서둘러 보고드리고 업체를 부르기로했다. 두 곳의 업체에 연락을 해야하는데 한 곳만 연락하고 한 곳은 연락을 안했다. 왜냐면 저번 견적에 엄청 다급히 말해놓고 팀장이 취소하라고 해서 취소해버렸다.
그 이후로 미안해서 더욱 전화하기 힘들었다.
그래서 자주 쓰지 않는 업체에 전화해서 얼른 서둘러 올 것을 요청했지만 주말이고 해서 안 오려 했다. 계속해서 거듭 사정하니 2시쯤 오겠다고 연락왔다.
안도의 한숨을 내쉬었다.  




```datacorejsx
////////////////////////////////////////////////////
///             Initial Settings                 ///
////////////////////////////////////////////////////

const initialSettings = {
  placeholders: {
    nameFilter: "Search files...",
    pathFilter: "Enter path...",
    dateFilter: "Enter date (YYYY-MM-DD)...",
    headerTitle: "Inbox",
  },
  excludedFolders: ["SYSTEM", "HUB", "DAILY"],
  pagination: {
    isEnabled: true,
    itemsPerPage: 7,
  },
  sortBy: "mtime", // 'mtime' for last modified, 'ctime' for creation date
  sortOrder: "desc", // 'desc' for descending, 'asc' for ascending
  statusValues: {
    todo: "1 Todo",
    completed: "4 Completed",
  },
  fileStateValues: {
    uncheckedTask: "unchecked_task",
    closedField: "closed",
  },
};

////////////////////////////////////////////////////
///               Helper Functions               ///
////////////////////////////////////////////////////

const buildExcludedFoldersQuery = (folders) => {
  return folders.map(folder => `!path("${folder}")`).join(' AND ');
};

const updateFrontmatter = async (app, entry, updates) => {
  const file = app.vault.getAbstractFileByPath(entry.$path);
  await app.fileManager.processFrontMatter(file, (frontmatter) => {
    Object.entries(updates).forEach(([key, value]) => {
      if (value === undefined) {
        delete frontmatter[key];
      } else {
        const existingKey = Object.keys(frontmatter).find(k => k.toLowerCase() === key.toLowerCase());
        if (existingKey) {
          frontmatter[existingKey] = value;
        } else {
          frontmatter[key] = value;
        }
      }
    });
  });
};

const getFullPath = (path) => {
  const parts = path.split('/');
  return parts.slice(0, -1).join(' > ');
};

const formatDate = (date) => {
  return date ? date.toFormat("yyyy-MM-dd") : "";
};

////////////////////////////////////////////////////
///             Display Rules                    ///
////////////////////////////////////////////////////

const displayRules = [
  {
    name: 'Incomplete Tasks',
    query: `(status != "${initialSettings.statusValues.completed}" OR status = null)`
  },
  {
    name: 'Unchecked Tasks',
    query: `(file_state = "${initialSettings.fileStateValues.uncheckedTask}")`
  },
  {
    name: 'Unattended Meetings',
    query: '(meeting_status = false OR meeting_status = null)'
  },
];

////////////////////////////////////////////////////
///         Completed Display Rules              ///
////////////////////////////////////////////////////

const completedDisplayRules = [
  {
    name: 'Completed Tasks',
    query: `(${initialSettings.fileStateValues.closedField} != null)`
  },
];

////////////////////////////////////////////////////
///             Checkbox Rules                   ///
////////////////////////////////////////////////////

const checkboxRules = [
  {
    condition: (entry) => entry.$frontmatter?.status !== undefined,
    getUpdates: (isChecked) => ({
      status: isChecked ? initialSettings.statusValues.todo : initialSettings.statusValues.completed,
      [initialSettings.fileStateValues.closedField]: isChecked ? undefined : dc.luxon.DateTime.now().toFormat("yyyy-MM-dd'T'HH:mm")
    }),
    getIcon: (updates) => updates.status === initialSettings.statusValues.todo ? 'circle' : 'lucide-check-circle'
  },
  {
    condition: (entry) => entry.$frontmatter?.file_state !== undefined,
    getUpdates: (isChecked) => isChecked
      ? { file_state: initialSettings.fileStateValues.uncheckedTask, [initialSettings.fileStateValues.closedField]: undefined }
      : { file_state: undefined, [initialSettings.fileStateValues.closedField]: dc.luxon.DateTime.now().toFormat("yyyy-MM-dd'T'HH:mm") },
    getIcon: (updates) => updates.file_state === initialSettings.fileStateValues.uncheckedTask ? 'circle' : 'lucide-check-circle'
  },
  {
    condition: (entry) => entry.$frontmatter?.scheduled_date !== undefined && entry.$frontmatter?.meeting_status !== undefined,
    getUpdates: () => ({ meeting_status: true, [initialSettings.fileStateValues.closedField]: dc.luxon.DateTime.now().toFormat("yyyy-MM-dd'T'HH:mm") }),
    getIcon: () => 'lucide-check-circle'
  },
];

////////////////////////////////////////////////////
///                 Components                   ///
////////////////////////////////////////////////////

const Link = ({ path, children }) => (
  <a target="_blank" rel="noopener" data-tooltip-position="top" data-href={path} className="internal-link">
    {children}
  </a>
);

const FolderPath = ({ path, date, sortBy }) => (
  <div style={styles.folderPathContainer}>
    <div>{getFullPath(path)}</div>
    <div>{sortBy === 'mtime' ? 'Last modified: ' : 'Creation Date: '}{formatDate(date)}</div>
  </div>
);

const Checkbox = ({ entry, onUpdate, isCompleted }) => {
  const closedField = initialSettings.fileStateValues.closedField;

  const isChecked = entry.$frontmatter?.status === initialSettings.statusValues.completed ||
                    entry.$frontmatter?.[closedField] !== undefined ||
                    entry.$frontmatter?.meeting_status === true;

  const icon = isChecked ? 'lucide-check-circle' : 'circle';

  const handleClick = async () => {
    if (isCompleted) return; // Do nothing for completed tasks

    const rule = checkboxRules.find(r => r.condition(entry));
    if (!rule) return;

    const updates = rule.getUpdates(isChecked);
    await updateFrontmatter(app, entry, updates);

    const iconic = app.plugins.getPlugin('iconic');
    if (iconic) {
      iconic.saveFileIcon({ id: entry.$path }, rule.getIcon(updates), null);
      iconic.refreshIconManagers();
    }

    onUpdate();
  };

  return (
    <a onClick={handleClick} style={{ marginRight: '5px', cursor: isCompleted ? 'default' : 'pointer' }}>
      <dc.Icon icon={icon} className="icon-in-link" />
    </a>
  );
};

const Row = ({ entry, onUpdate, sortBy, showCheckbox }) => {
  return (
    <div style={styles.row}>
      <Checkbox entry={entry} onUpdate={onUpdate} isCompleted={!showCheckbox} />
      <Link path={entry.$path}>{entry.$name}</Link>
      <FolderPath path={entry.$path} date={sortBy === 'mtime' ? entry.$mtime : entry.$ctime} sortBy={sortBy} />
    </div>
  );
};

const PaginationControls = ({ currentPage, totalPages, onPageChange, pageInput, setPageInput, totalEntries }) => (
  <div style={styles.pagination}>
    <dc.Button
      onClick={() => onPageChange(currentPage - 1)}
      disabled={currentPage === 1}
      style={styles.button}
    >
      Previous
    </dc.Button>
    <span style={styles.paginationText}>
      Page {currentPage} of {totalPages}
    </span>
    <dc.Textbox
      type="number"
      min="1"
      max={totalPages}
      value={pageInput}
      placeholder="Page #"
      onChange={(e) => setPageInput(e.target.value)}
      onKeyDown={(e) => {
        if (e.key === "Enter") {
          const pageNumber = parseInt(pageInput, 10);
          if (!isNaN(pageNumber)) onPageChange(pageNumber);
        }
      }}
      style={styles.paginationTextbox}
    />
    <dc.Button
      onClick={() => {
        const pageNumber = parseInt(pageInput, 10);
        if (!isNaN(pageNumber)) onPageChange(pageNumber);
      }}
      style={styles.button}
    >
      Go
    </dc.Button>
    <dc.Button
      onClick={() => onPageChange(currentPage + 1)}
      disabled={currentPage === totalPages}
      style={styles.button}
    >
      Next
    </dc.Button>
    <span style={styles.totalEntries}>Total Entries: {totalEntries}</span>
  </div>
);

////////////////////////////////////////////////////
///             Main View Component              ///
////////////////////////////////////////////////////

function Inbox() {
  const { useState, useMemo, useCallback } = dc;
  const [nameFilter, setNameFilter] = useState("");
  const [pathFilter, setPathFilter] = useState("");
  const [updateTrigger, setUpdateTrigger] = useState(0);
  const [isEditing, setIsEditing] = useState(false);
  const [showCompleted, setShowCompleted] = useState(false);
  const [paginationEnabled, setPaginationEnabled] = useState(initialSettings.pagination.isEnabled);
  const [itemsPerPage, setItemsPerPage] = useState(initialSettings.pagination.itemsPerPage);
  const [currentPage, setCurrentPage] = useState(1);
  const [pageInput, setPageInput] = useState("");
  const [sortBy, setSortBy] = useState(initialSettings.sortBy);
  const [sortOrder, setSortOrder] = useState(initialSettings.sortOrder);
  const [dateFilter, setDateFilter] = useState("");
  const [isDateBefore, setIsDateBefore] = useState(false);

  const excludedFoldersQuery = useMemo(() => buildExcludedFoldersQuery(initialSettings.excludedFolders), []);
  const displayRulesQuery = useMemo(() => {
    return showCompleted
      ? completedDisplayRules.map(rule => rule.query).join(' OR ')
      : displayRules.map(rule => rule.query).join(' OR ');
  }, [showCompleted]);

  const query = dc.useQuery(`@page AND (${displayRulesQuery}) AND ${excludedFoldersQuery} ${pathFilter ? `AND path("${pathFilter}")` : ''}`, [updateTrigger, pathFilter]);

  const filteredData = useMemo(() => {
    return query
      .filter(entry => entry.$name.toLowerCase().includes(nameFilter.toLowerCase()))
      .filter(entry => {
        if (showCompleted) {
          return entry.$frontmatter?.[initialSettings.fileStateValues.closedField] !== undefined;
        }
        return true;
      })
      .filter(entry => {
        if (!dateFilter) return true;
        
        const entryDate = sortBy === 'mtime' ? entry.$mtime : entry.$ctime;
        const filterDate = dc.luxon.DateTime.fromFormat(dateFilter, "yyyy-MM-dd").startOf('day');
        
        if (!filterDate.isValid) return true;
        
        return isDateBefore 
          ? entryDate <= filterDate
          : entryDate >= filterDate;
      })
      .sort((a, b) => {
        const dateA = sortBy === 'mtime' ? a.$mtime : a.$ctime;
        const dateB = sortBy === 'mtime' ? b.$mtime : b.$ctime;
        return sortOrder === 'asc' ? dateA - dateB : dateB - dateA;
      });
  }, [query, nameFilter, sortBy, sortOrder, showCompleted, dateFilter, isDateBefore]);

  const paginatedData = useMemo(() => {
    if (!paginationEnabled) return filteredData;
    const start = (currentPage - 1) * itemsPerPage;
    const end = start + itemsPerPage;
    return filteredData.slice(start, end);
  }, [filteredData, paginationEnabled, currentPage, itemsPerPage]);

  const totalPages = useMemo(() => {
    return paginationEnabled ? Math.ceil(filteredData.length / itemsPerPage) : 1;
  }, [filteredData, paginationEnabled, itemsPerPage]);

  const handleUpdate = useCallback(() => setUpdateTrigger(prev => prev + 1), []);

  const handlePageChange = useCallback((newPage) => {
    if (newPage >= 1 && newPage <= totalPages) {
      setCurrentPage(newPage);
      setPageInput("");
    }
  }, [totalPages]);

  const toggleSortOrder = useCallback(() => {
    setSortOrder(prev => prev === 'asc' ? 'desc' : 'asc');
  }, []);

  return (
    <div style={styles.container}>
      <h1 style={styles.header}>{initialSettings.placeholders.headerTitle}</h1>
      <div style={styles.controls}>
        <dc.Textbox
          type="search"
          placeholder={initialSettings.placeholders.nameFilter}
          value={nameFilter}
          onChange={(e) => setNameFilter(e.target.value)}
          style={styles.searchBox}
        />
        <dc.Textbox
          type="search"
          placeholder={initialSettings.placeholders.pathFilter}
          value={pathFilter}
          onChange={(e) => setPathFilter(e.target.value)}
          style={styles.searchBox}
        />
        <label style={styles.toggleLabel}>
          <input
            type="checkbox"
            checked={showCompleted}
            onChange={(e) => setShowCompleted(e.target.checked)}
          />
          Completions
        </label>
      </div>
      <div style={styles.secondaryControls}>
        <div style={styles.dateFilterContainer}>
          <dc.Textbox
            type="search"
            placeholder={initialSettings.placeholders.dateFilter}
            value={dateFilter}
            onChange={(e) => setDateFilter(e.target.value)}
            style={styles.dateFilterBox}
          />
          <button 
            onClick={() => setIsDateBefore(!isDateBefore)} 
            style={{
              ...styles.button,
              ...styles.dateToggleButton,
              backgroundColor: isDateBefore ? 'var(--interactive-accent)' : 'var(--background-modifier-border-focus)',
            }}
          >
            {isDateBefore ? 'Before' : 'After'}
          </button>
        </div>
        <button onClick={() => setIsEditing(!isEditing)} style={styles.button}>
          {isEditing ? "Finish Editing" : "Edit"}
        </button>
      </div>
      {isEditing && (
        <div style={styles.editingControls}>
          <label>
            <input
              type="checkbox"
              checked={paginationEnabled}
              onChange={(e) => setPaginationEnabled(e.target.checked)}
            />
            Enable Pagination
          </label>
          {paginationEnabled && (
            <dc.Textbox
              type="number"
              value={itemsPerPage}
              onChange={(e) => setItemsPerPage(Number(e.target.value))}
              style={styles.numberInput}
              min="1"
            />
          )}
          <select value={sortBy} onChange={(e) => setSortBy(e.target.value)} style={styles.select}>
            <option value="mtime">Sort by Last Modified</option>
            <option value="ctime">Sort by Creation Date</option>
          </select>
          <button onClick={toggleSortOrder} style={styles.button}>
            {sortOrder === 'asc' ? '↑ Ascending' : '↓ Descending'}
          </button>
        </div>
      )}
      <div style={styles.rowsContainer}>
        {paginatedData.map((entry, index) => (
          <Row key={index} entry={entry} onUpdate={handleUpdate} sortBy={sortBy} showCheckbox={!showCompleted} />
        ))}
      </div>
      {paginationEnabled && (
        <PaginationControls
          currentPage={currentPage}
          totalPages={totalPages}
          onPageChange={handlePageChange}
          pageInput={pageInput}
          setPageInput={setPageInput}
          totalEntries={filteredData.length}
        />
      )}
    </div>
  );
}

////////////////////////////////////////////////////
///                   Styles                     ///
////////////////////////////////////////////////////

const styles = {
  container: {
    padding: "20px",
    backgroundColor: "var(--background-primary)",
    color: "var(--text-normal)",
    height: "100%",
    display: "flex",
    flexDirection: "column",
  },
  header: { marginBottom: "20px" },
  controls: {
    display: "flex",
    gap: "10px",
    marginBottom: "10px",
  },
  searchBox: {
    flex: 1,
    padding: "8px",
    border: "1px solid var(--background-modifier-border)",
    borderRadius: "4px",
    backgroundColor: "var(--background-primary)",
    color: "var(--text-normal)",
  },
  button: {
    padding: "8px 16px",
    backgroundColor: "var(--interactive-accent)",
    color: "var(--text-on-accent)",
    border: "none",
    borderRadius: "4px",
    cursor: "pointer",
    fontWeight: "bold",
  },
  toggleLabel: {
    display: "flex",
    alignItems: "center",
    gap: "5px",
    "& input[type='checkbox']": {
      display: "none",
    },
  },
  editingControls: {
    display: "flex",
    gap: "10px",
    marginBottom: "20px",
    alignItems: "center",
  },
  numberInput: {
    width: "60px",
    padding: "4px",
  },
  select: {
    padding: "4px",
  },
  rowsContainer: {
    flex: 1,
    overflowY: "auto",
  },
  row: {
    marginBottom: "10px",
    paddingBottom: "10px",
    borderBottom: "1px solid var(--background-modifier-border)",
  },
  folderPathContainer: {
    display: "flex",
    flexDirection: "column",
    marginLeft: "20px",
    color: "var(--text-muted)",
    fontSize: "0.9em",
  },
  pagination: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    gap: "10px",
    marginTop: "20px",
  },
  paginationText: {
    margin: "0 10px",
  },
  paginationTextbox: {
    width: "60px",
    padding: "4px",
  },
  totalEntries: {
    marginLeft: "20px",
  },
  secondaryControls: {
    display: "flex",
    gap: "10px",
    marginBottom: "20px",
    alignItems: "center",
  },
  dateFilterContainer: {
    display: "flex",
    alignItems: "center",
    gap: "10px",
    flex: 1,
  },
  dateFilterBox: {
    flex: 1,
    padding: "8px",
    border: "1px solid var(--background-modifier-border)",
    borderRadius: "4px",
    backgroundColor: "var(--background-primary)",
    color: "var(--text-normal)",
  },
  dateToggleButton: {
    minWidth: "80px",
    padding: "6px 12px",
    transition: "background-color 0.3s",
  },
};

return <Inbox />;
```

	


### 더스크 페이지
## 사진 속 당신은 그날 어떤 소리에 잠에서 깼고, 무얼 먹었으며, 누구와 어떤 대화를 나눴을까요? 그 사진은 그 하루 중 언제, 누가, 왜 찍었을까요. 그 날의 하루를 최대한 구체적으로 ‘재구성’해보세요.

맞벌이하시는 부모님이 아침에 분주하게 준비하는 소리에 나도 덩달아 일어났다. 어릴 적 나는 아침에 일어날 시간이면 몇 분이라도 더 자고 싶어, 일단 씻고 나와 다시 침대에 누워 잠들곤 했다. 그날 아침도 그랬다. 문이 쾅 열리며 엄마 목소리가 들렸다. "고용준, 일어나!" 남자아이 방인데도 엄마는 그냥 문을 확 열어 버리셨다. 우리 집엔 프라이버시란 없었다.
내 방은 화장실 옆이라 씻는 물소리가 다 들렸는데, 그날도 누나가 씻는 소리를 듣고 교복을 입은 뒤 다시 침대에 누워 이불을 덮었다. 엄마가 "고용준, 씻었어?" 하고 물으시자 나는 자동반사적으로 "네, 씻었어요."라고 대답했다. 역시나, 다시 문이 쾅 열렸다. 이불이 홱 젖혀졌다. 화난 엄마는 아랫입술을 깨물며 말했다. "하, 진짜 죽을래?" 매 맞는 게 무서웠기에 얼른 일어났다.
텅 빈 화장실에 들어가 씻었다. 우리 집은 원래 아침을 안 먹어서, 학교 갈 시간까지 TV를 보다가 학교에 가면 되었다. 그날은 사진 찍는 날이라 부모님 방에 들어가 헤어스프레이를 뿌려 멋을 좀 냈다. 부모님이 출근하시면 나는 TV를 틀어 놓고 누워서 보다가 학교에 갔다.
초등학교는 바로 앞이라 다니기 편했지만, 중학교는 대각선 방향에 있었고 정문은 완전 반대편이었다. 나는 항상 TV를 보다가 정문이 닫히는 8시 30분쯤에야 아슬아슬하게 도착하곤 했다. 좀 늦을 것 같다 싶으면 항상 담벼락을 탔다. 꽤 높은 담벼락이었는데도 나는 곧잘 넘었다. 나중에는 다른 학생들도 나를 따라 하기 시작했다. 그래서 담을 넘다가 학주에게 몇 번씩 걸려 오리걸음을 한 적도 있다.
그날은 그래도 일찍 나섰기에 정문으로 갔다. 정문으로 가는 길에 나는 불량식품 마니아라서, 일주일 용돈 500원을 하루 만에 탕진하며 풍선껌을 사곤 했다. 그걸 친구들에게 나눠주며 이야기했다.
우리 반에는 불량한 친구들이 많았는데, 나는 곧잘 괴롭힘을 당했다. 그날도 헤드록을 몇 번이나 당했다. 왜소하고 순둥순둥하게 생겨 약해 보였던 탓일까. 그때 나는 키가 작아 항상 맨 앞자리였고, 번호도 14번이었다. 그래서 매일 밤 키가 커서 나쁜 녀석들을 혼내주겠다고 다짐했다. 그렇게 괴롭힘을 당하고 집에 오면 항상 문 앞에서 키를 재보곤 했던 것 같다.

점심시간쯤 사진사 아저씨가 학교에 와서 차례대로 사진을 찍었다. 학생증 사진이라고 했던 것 같다. 평소에는 한적했던 탈의실에 배경 천을 걸어놓고 찍었는데, 정확히 몇 층이었는지는 기억나지 않지만 중앙 계단 옆 탈의실이었다. 교무실이 2층이었으니 아마 3층이 아니었을까 싶다. 그 탈의실은 옷 갈아입을 때 빼고는 들어가 볼 일 없는 곳이었는데, 그날은 그곳이 마치 아무 사진관인 것처럼 사진을 찍으러 들어갔던 것 같다. 아이들은 하나둘씩 줄지어 들어가 사진을 한두 컷 찍고 "다음!" 하는 소리에 사진사 아저씨에게 배꼽 인사를 하고 나왔다. 정말 별 생각 없이 찍었던 것 같다. 사진사 아저씨는 거의 기계적으로 사진을 찍어댔다. 지금 생각하면 '저분, 누군가의 연줄로 들어왔겠지?' 하는 생각이 문득 든다. 나도 인생의 어두운 면부터 보게 되는 어른이 되어버린 걸까?

그때 누구와 주로 대화했는지는 잘 기억나지 않는다. 나는 항상 겉도는 편이어서 불량 친구들과 어울릴 때도 많았다. 그 무렵 그 친구들에게서 침 뱉는 법과 욕하는 법을 익혔다. 나는 점점 나쁜 친구들과 어울리며 겉멋이 들었지만, 속은 아직 여렸다. 당시 욕은 엄청나게 했지만, 그냥 그때 유행 같은 것이었다. "씨발"이라는 단어가 거의 모든 말에 들어갔던 것 같다. 그런데 나는 부모님 욕은 하지 않았던 것 같다. 그건 뭔가 저급해 보였고, 당시 유행이라 할지라도 멋있어 보이지 않았다.
나는 볼살이 참 통통했다. 그게 항상 콤플렉스여서, 어른들이 크면 '젖살이라 다 빠진다'고 하는 말을 거짓말이라고 생각했다. 지금 생각하면 통통하고 동글동글한 도토리 같았던 그때의 내 모습이 그립다.

# Overview

````tabs
tab: Meetings
```dataviewjs
let meetings = dv.pages('"PARA/RESOURCES/MEETINGS"')
    .where(m => m.meeting_status === false && m.type === "meeting");

// Separate meetings with and without scheduled dates
let withDates = meetings.where(m => m.scheduled_date);
let withoutDates = meetings.where(m => !m.scheduled_date);

// Sort meetings with dates by scheduled date
withDates = withDates.sort(m => m.scheduled_date);

// Combine both lists, with meetings having dates first
let allMeetings = withDates.concat(withoutDates);

// Render the table with clickable meeting links
dv.table(
    ["Days", "Meeting", "Scheduled Date", "Start Time", "End Time"],
    allMeetings.map(m => [
        m.scheduled_date ? Math.floor(dv.date(m.scheduled_date).diff(dv.date("today"), 'days').days) : "-", // Calculate days until the meeting
        m.file.link, // Use m.file.link to render the meeting name as a clickable link
        m.scheduled_date ? dv.date(m.scheduled_date).toFormat("MM-dd") : "-",
        m.start_time || "-",
        m.end_time || "-"
    ])
);
```
tab: Projects
```dataviewjs
let pages = dv.pages('"PARA/PROJECTS"')
    .where(p => (p.type == "project_note" || p.type == "project_family") && p.Status != "4 Completed");

// Separate pages with and without due dates
let withDueDates = pages.where(p => p.Due_Date != null);
let withoutDueDates = pages.where(p => p.Due_Date == null);

// Sort pages with due dates by: Due Date -> Priority Level (A-Z) -> Status (Z-A)
withDueDates = withDueDates.sort(p => p.Due_Date)
    .sort(p => p.Priority_Level)
    .sort(p => p.Status, 'desc');

// Sort pages without due dates by: Priority Level (A-Z) -> Status (Z-A)
withoutDueDates = withoutDueDates.sort(p => p.Priority_Level)
    .sort(p => p.Status, 'desc');

// Combine both lists
let allPages = withDueDates.concat(withoutDueDates);

// Render the table with clickable project links
dv.table(
    ["Days", "Project", "Priority Level", "Status", "Due Date"],
    allPages.map(p => [
        p.Due_Date ? Math.floor(dv.date(p.Due_Date).diff(dv.date("today"), 'days').days) : "-", // Display whole number of days
        p.file.link, // Use p.file.link to render the project name as a clickable link
        p.Priority_Level || "-",
        p.Status || "-",
        p.Due_Date ? dv.date(p.Due_Date).toFormat("MM-dd") : "-"
    ])
);
```
tab: Areas
```dataview
table area_category as "Area Category", created as "Date Created" from "PARA/AREAS"
WHERE type = "area_family"
```
````


