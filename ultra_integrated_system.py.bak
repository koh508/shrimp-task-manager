import asyncio
import json
import logging
import os
import shutil
import time
from datetime import datetime
import webbrowser
from pathlib import Path
from typing import Dict, List, Optional, Any
import aiofiles
import aiohttp
import websockets
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload, MediaIoBaseDownload
import hashlib
import sqlite3
from dataclasses import dataclass, asdict
from watchfiles import awatch, Change
import threading
import queue
from plugin_manager import PluginManager


@dataclass
class SyncEvent:
    """ë™ê¸°í™” ì´ë²¤íŠ¸ ë°ì´í„° êµ¬ì¡°"""
    event_type: str
    source: str
    file_path: str
    target: Optional[str] = None
    content: Optional[str] = None
    metadata: Optional[Dict] = None
    timestamp: str = None

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now().isoformat()


class TriSyncManager:
    def __init__(self, config: Dict):
        self.config = config
        self.obsidian_path = Path(config.get('obsidian_vault_path'))
        self.gdrive_folder_id = config.get('gdrive_folder_id')
        self.agent_workspace = Path(config.get('agent_workspace'))

        self.sync_queue = asyncio.Queue()
        self.sync_lock = asyncio.Lock()
        self.shutdown_event = asyncio.Event()
        self.running = False
        self.init_sync_db()

    def init_sync_db(self):
        """ë™ê¸°í™” ìƒíƒœ ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”"""
        self.agent_workspace.mkdir(parents=True, exist_ok=True)
        self.db_path = self.agent_workspace / "sync_state.db"
        self.conn = sqlite3.connect(str(self.db_path), check_same_thread=False)
        # ... (í…Œì´ë¸” ìƒì„± SQLì€ ë™ì¼)
        self.conn.execute(
            """
            CREATE TABLE IF NOT EXISTS file_states (
                file_path TEXT PRIMARY KEY,
                obsidian_hash TEXT,
                gdrive_hash TEXT,
                agent_hash TEXT,
                last_sync TIMESTAMP,
                sync_status TEXT
            )
        """
        )
        self.conn.execute(
            """
            CREATE TABLE IF NOT EXISTS sync_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_type TEXT,
                source TEXT,
                target TEXT,
                file_path TEXT,
                timestamp TIMESTAMP,
                status TEXT,
                error_message TEXT
            )
        """
        )
        self.conn.commit()

    async def _watch_directory(self, path: str, source: str):
        """ë””ë ‰í† ë¦¬ ê°ì‹œ"""
        path_obj = Path(path)
        path_obj.mkdir(parents=True, exist_ok=True)
        logging.info(f"[{source}] '{path}' ê²½ë¡œì— ëŒ€í•œ íŒŒì¼ ê°ì‹œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.")
        try:
            async for changes in awatch(path, stop_event=self.shutdown_event):
                if not self.running:
                    break
                for change_type, file_path_str in changes:
                    logging.info(f"[{source}] íŒŒì¼ ì´ë²¤íŠ¸ ê°ì§€: {change_type.name} - {file_path_str}")
                    event = SyncEvent(event_type=change_type.name, source=source, file_path=str(file_path_str))
                    await self.sync_queue.put(event)
        except Exception as e:
            logging.error(f"[{source}] íŒŒì¼ ê°ì‹œ ì˜¤ë¥˜: {e}", exc_info=True)
        finally:
            logging.info(f"[{source}] '{path}' ê²½ë¡œì— ëŒ€í•œ íŒŒì¼ ê°ì‹œë¥¼ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤.")

    async def sync_processor(self):
        """ë™ê¸°í™” ì´ë²¤íŠ¸ ì²˜ë¦¬ê¸°"""
        while self.running:
            try:
                event = await self.sync_queue.get()
                await self.process_sync_event(event)
                self.sync_queue.task_done()
            except asyncio.CancelledError:
                break
            except Exception as e:
                logging.error(f"ë™ê¸°í™” ì²˜ë¦¬ ì˜¤ë¥˜: {e}", exc_info=True)
    
    async def process_sync_event(self, event: SyncEvent):
        # ... (ì´ì „ê³¼ ë™ì¼)
        pass

    async def start_sync_system(self):
        """ë™ê¸°í™” ì‹œìŠ¤í…œì˜ ë©”ì¸ ì´ë²¤íŠ¸ ë£¨í”„ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤."""
        self.running = True
        self.shutdown_event.clear()
        logging.info("ë™ê¸°í™” ì‹œìŠ¤í…œì˜ ë©”ì¸ ì´ë²¤íŠ¸ ë£¨í”„ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.")
        tasks = [
            asyncio.create_task(self.sync_processor()),
            asyncio.create_task(self._watch_directory(str(self.obsidian_path), 'obsidian')),
            asyncio.create_task(self._watch_directory(str(self.agent_workspace), 'agent'))
        ]
        try:
            await asyncio.gather(*tasks)
        except asyncio.CancelledError:
            logging.info("ë™ê¸°í™” ì‹œìŠ¤í…œ íƒœìŠ¤í¬ê°€ ì™¸ë¶€ ìš”ì²­ì— ì˜í•´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
        finally:
            for task in tasks:
                if not task.done():
                    task.cancel()
            await asyncio.gather(*tasks, return_exceptions=True)
            logging.info("ë™ê¸°í™” ì‹œìŠ¤í…œì˜ ëª¨ë“  íƒœìŠ¤í¬ë¥¼ ì •ë¦¬í•˜ê³  ì¢…ë£Œí•©ë‹ˆë‹¤.")

    async def stop_sync_system(self):
        """ë™ê¸°í™” ì‹œìŠ¤í…œì„ ì•ˆì „í•˜ê²Œ ì¢…ë£Œí•©ë‹ˆë‹¤."""
        if not self.running:
            return
        logging.info("ë™ê¸°í™” ì‹œìŠ¤í…œ ì¢…ë£Œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...")
        self.running = False
        self.shutdown_event.set()
        # sync_processorê°€ íì—ì„œ ë¹ ì ¸ë‚˜ì˜¤ë„ë¡ ë”ë¯¸ ì´ë²¤íŠ¸ ì¶”ê°€
        await self.sync_queue.put(None)


class UltraIntegratedSystem:
    def __init__(self, config_path: str = "config.json"):
        self.config = self._load_config(config_path)
        self._setup_logging()
        self.tri_sync_manager = TriSyncManager(self.config)
        self.plugin_manager = PluginManager()
        self.running = False
        self.tasks = []

    def _load_config(self, config_path: str) -> Dict:
        default_config = {
            "obsidian_vault_path": "./obsidian_vault",
            "gdrive_folder_id": "",
            "agent_workspace": "./agent_workspace",
            "sync_interval": 30,
            "log_level": "INFO"
        }
        try:
            with open(config_path, "r", encoding="utf-8") as f:
                user_config = json.load(f)
            default_config.update(user_config)
        except FileNotFoundError:
            print(f"INFO: '{config_path}' íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.")
            with open(config_path, "w", encoding="utf-8") as f:
                json.dump(default_config, f, indent=2, ensure_ascii=False)
        return default_config

    def _setup_logging(self):
        log_level_str = self.config.get("log_level", "INFO").upper()
        log_level = getattr(logging, log_level_str, logging.INFO)
        logging.basicConfig(
            level=log_level,
            format='%(asctime)s - %(levelname)s - [%(funcName)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S',
            handlers=[
                logging.FileHandler("ultra_integrated_system.log", encoding="utf-8"),
                logging.StreamHandler()
            ]
        )
        logging.info("ë¡œê¹… ì‹œìŠ¤í…œì´ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.")

    async def start(self):
        """í†µí•© ì‹œìŠ¤í…œ ì‹œì‘"""
        self.running = True
        logging.info("ğŸš€ Ultra Integrated System ì‹œì‘")
        try:
            await self.plugin_manager.load_plugins()
            sync_task = asyncio.create_task(self.tri_sync_manager.start_sync_system())
            self.tasks.append(sync_task)
            plugin_task = asyncio.create_task(self.plugin_manager.run_all())
            self.tasks.append(plugin_task)
            logging.info("âœ… ëª¨ë“  ì‹œìŠ¤í…œì´ ì„±ê³µì ìœ¼ë¡œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. Ctrl+Cë¥¼ ëˆŒëŸ¬ ì¢…ë£Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
            await asyncio.gather(*self.tasks)
        except asyncio.CancelledError:
            logging.info("ì‹œìŠ¤í…œì˜ ë©”ì¸ íƒœìŠ¤í¬ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
        finally:
            self.running = False

    async def stop(self):
        """ì‹œìŠ¤í…œ ì¢…ë£Œ"""
        if not self.running:
            return
        logging.info("ì‹œìŠ¤í…œ ì¢…ë£Œ ì‹œì‘...")
        self.running = False
        if self.tri_sync_manager:
            await self.tri_sync_manager.stop_sync_system()
        if self.plugin_manager:
            await self.plugin_manager.stop_all()
        for task in self.tasks:
            if not task.done():
                task.cancel()
        await asyncio.gather(*self.tasks, return_exceptions=True)
        logging.info("âœ… ì‹œìŠ¤í…œ ì¢…ë£Œ ì™„ë£Œ")

async def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    system = None
    try:
        system = UltraIntegratedSystem()
        await system.start()
    except KeyboardInterrupt:
        logging.info("ì‚¬ìš©ìì— ì˜í•œ ì‹œìŠ¤í…œ ì¢…ë£Œ ìš”ì²­ (KeyboardInterrupt)")
    except Exception as e:
        logging.error(f"ì‹œìŠ¤í…œ ì‹¤í–‰ ì¤‘ ì²˜ë¦¬ë˜ì§€ ì•Šì€ ì˜ˆì™¸ ë°œìƒ: {e}", exc_info=True)
    finally:
        if system:
            await system.stop()
        logging.info("í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except RuntimeError as e:
        if "This event loop is already running" in str(e):
            loop = asyncio.get_event_loop()
            if loop.is_running():
                task = loop.create_task(main())
                task.add_done_callback(
                    lambda t: loop.stop() if not loop.is_running() else None
                )
            else:
                loop.run_until_complete(main())
        else:
            raise
        self.last_hash = {}
        self.last_content = {}
        self.change_threshold = 10

    def detect_meaningful_change(self, file_path: str, content: str) -> bool:
        """ì˜ë¯¸ ìˆëŠ” ë³€í™” ê°ì§€"""
        current_hash = hashlib.md5(content.encode()).hexdigest()
        last_hash = self.last_hash.get(file_path)
        if current_hash == last_hash:
            return False
        last_content = self.last_content.get(file_path, "")
        if abs(len(content) - len(last_content)) < self.change_threshold:
            return False
        self.last_hash[file_path] = current_hash
        self.last_content[file_path] = content
        return True


class IntegratedTitleGenerator:
    """í†µí•© ì œëª© ìƒì„±ê¸°"""

    def __init__(self):
        # These are placeholder generators
        # self.keyword_gen = KeywordTitleGenerator()
        # self.summary_gen = SummaryTitleGenerator()
        # self.llm_gen = LLMTitleGenerator()
        pass

    def generate_title(self, content: str) -> str:
        """ì½˜í…ì¸  ê¸°ë°˜ ì œëª© ìƒì„±"""
        return f"ë…¸íŠ¸_{datetime.now().strftime('%H%M%S')}"  # Placeholder


class GoogleDriveManager:
    """êµ¬ê¸€ë“œë¼ì´ë¸Œ ë§¤ë‹ˆì €"""

    def __init__(self, folder_id: str):
        self.folder_id = folder_id
        self.service = None
        self.file_cache = {}
        self.sync_queue = asyncio.Queue()

    async def initialize(self):
        """êµ¬ê¸€ë“œë¼ì´ë¸Œ ë§¤ë‹ˆì € ì´ˆê¸°í™”"""
        try:
            creds = self.load_credentials()
            self.service = build("drive", "v3", credentials=creds)
            logging.info("ğŸ”‘ êµ¬ê¸€ë“œë¼ì´ë¸Œ ë§¤ë‹ˆì € ì´ˆê¸°í™” ì™„ë£Œ")
            # asyncio.create_task(self.sync_worker())
            # asyncio.create_task(self.watch_changes())
        except Exception as e:
            logging.error(f"êµ¬ê¸€ë“œë¼ì´ë¸Œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")

    def load_credentials(self) -> Credentials:
        """êµ¬ê¸€ë“œë¼ì´ë¸Œ ì¸ì¦ ì •ë³´ ë¡œë“œ"""
        creds_json = os.getenv("GOOGLE_DRIVE_CREDENTIALS")
        if creds_json:
            creds_info = json.loads(creds_json)
            return Credentials.from_authorized_user_info(creds_info)
        creds_file = Path("google_drive_credentials.json")
        if creds_file.exists():
            return Credentials.from_authorized_user_file(str(creds_file))
        raise Exception("êµ¬ê¸€ë“œë¼ì´ë¸Œ ì¸ì¦ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")


class AgentManager:
    """AI ì—ì´ì „íŠ¸ í•µì‹¬ ë§¤ë‹ˆì €"""

    def __init__(self, workspace_path: Path):
        self.workspace_path = workspace_path
        self.watcher = None
        self.event_handler = None
        self.processing_queue = asyncio.Queue()
        # Placeholders for other components
        # self.learning_engine = None
        # self.memory_system = None
        # self.goal_hierarchy = None
        # self.mcp_client = None

    async def initialize(self):
        """ì—ì´ì „íŠ¸ ë§¤ë‹ˆì € ì´ˆê¸°í™”"""
        self.workspace_path.mkdir(parents=True, exist_ok=True)
        logging.info(f"ğŸ¤– ì—ì´ì „íŠ¸ ë§¤ë‹ˆì € ì´ˆê¸°í™” ì™„ë£Œ: {self.workspace_path}")


class UltraIntegratedSystem:
    """ì˜µì‹œë””ì–¸-êµ¬ê¸€ë“œë¼ì´ë¸Œ-ì—ì´ì „íŠ¸ í†µí•© ì‹œìŠ¤í…œ"""

    def __init__(self, config_path: str = "config.json"):
        self.config = self._load_config(config_path)
        self._setup_logging()
        self.tri_sync_manager = TriSyncManager(self.config)
        self.plugin_manager = PluginManager(config=self.config)
        self.running = False

    def _load_config(self, config_path: str) -> Dict:
        """ì„¤ì • íŒŒì¼ì„ ë¡œë“œí•˜ê³ , ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤."""
        default_config = {
            "obsidian_vault_path": "./obsidian_vault",
            "gdrive_folder_id": os.getenv("GDRIVE_FOLDER_ID", ""),
            "agent_workspace": "./agent_workspace",
            "sync_interval": 30,
            "log_level": "INFO",
            "backup_enabled": True,
            "conflict_resolution": "merge",
        }
        try:
            with open(config_path, "r", encoding="utf-8") as f:
                user_config = json.load(f)
            default_config.update(user_config)
            return default_config
        except FileNotFoundError:
            # config.jsonì´ ì—†ì„ ë•Œ ê¸°ë³¸ ë¡œê¹…ì„ ìœ„í•´ ì„ì‹œ ë©”ì‹œì§€ ì¶œë ¥
            print(f"INFO: '{config_path}' íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.")
            with open(config_path, "w", encoding="utf-8") as f:
                json.dump(default_config, f, indent=2, ensure_ascii=False)
            return default_config

    async def start(self):
        """í†µí•© ì‹œìŠ¤í…œ ì‹œì‘"""
        try:
            self.running = True
            logging.info("ğŸš€ Ultra Integrated System ì‹œì‘")

            # í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
            await self.plugin_manager.load_plugins()

            # ë™ê¸°í™” ì‹œìŠ¤í…œ ì‹œì‘
            sync_task = asyncio.create_task(self.tri_sync_manager.start_sync_system())
            self.tasks.append(sync_task)

            # í”ŒëŸ¬ê·¸ì¸ ì‹¤í–‰
            plugin_task = asyncio.create_task(self.plugin_manager.run_all())
            self.tasks.append(plugin_task)

            logging.info("âœ… ëª¨ë“  ì‹œìŠ¤í…œì´ ì„±ê³µì ìœ¼ë¡œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. Ctrl+Cë¥¼ ëˆŒëŸ¬ ì¢…ë£Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
            await asyncio.gather(*self.tasks)

        except asyncio.CancelledError:
            logging.info("ì‹œìŠ¤í…œì˜ ë©”ì¸ íƒœìŠ¤í¬ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
        except Exception as e:
            logging.error(f"ì‹œìŠ¤í…œ ì‹œì‘ ì‹¤íŒ¨: {e}", exc_info=True)
            raise
        finally:
            self.running = False

    async def stop(self):
        """ì‹œìŠ¤í…œ ì¢…ë£Œ"""
        if not self.running:
            return
        self.running = False
        logging.info("ì‹œìŠ¤í…œ ì¢…ë£Œ ì‹œì‘...")

        # ë™ê¸°í™” ì‹œìŠ¤í…œ ì¢…ë£Œ
        if self.tri_sync_manager:
            await self.tri_sync_manager.stop_sync_system()

        # í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ ì¢…ë£Œ
        if self.plugin_manager:
            await self.plugin_manager.stop_all()

        # ëª¨ë“  ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬ ì·¨ì†Œ
        for task in self.tasks:
            if not task.done():
                task.cancel()
        
        # ëª¨ë“  íƒœìŠ¤í¬ê°€ ì™„ì „íˆ ì¢…ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
        await asyncio.gather(*self.tasks, return_exceptions=True)

        logging.info("âœ… ì‹œìŠ¤í…œ ì¢…ë£Œ ì™„ë£Œ")

async def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    system = None
    try:
        system = UltraIntegratedSystem()
        await system.start()
    except KeyboardInterrupt:
        logging.info("ì‚¬ìš©ìì— ì˜í•œ ì‹œìŠ¤í…œ ì¢…ë£Œ ìš”ì²­ (KeyboardInterrupt)")
    except Exception as e:
        logging.error(f"ì‹œìŠ¤í…œ ì‹¤í–‰ ì¤‘ ì²˜ë¦¬ë˜ì§€ ì•Šì€ ì˜ˆì™¸ ë°œìƒ: {e}", exc_info=True)
    finally:
        if system:
            await system.stop()
        logging.info("í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except RuntimeError as e:
        if "This event loop is already running" in str(e):
            loop = asyncio.get_event_loop()
            if loop.is_running():
                task = loop.create_task(main())
                task.add_done_callback(
                    lambda t: loop.stop() if not loop.is_running() else None
                )
            else:
                loop.run_until_complete(main())
        else:
            raise
    system = UltraIntegratedSystem()
    asyncio.run(system.start())
